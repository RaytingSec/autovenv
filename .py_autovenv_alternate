#!/bin/bash
# .py_autovenv
# 
# What:
#   The idea is venv acts intuitively and smoothly like Git repositories:
#
#       - In a project dir with a .venv subdir, that venv is used.
#       - Navigate to another subdir, the .venv is still used.
#       - When the project is left, the .venv is deactivate automatically.
#       - Closer venv will be prioritized in nested projects
#
#   You don't type `source .git/bin/activate` and `deactivate` when changing
#   between git repositories, do you?
#
# Installation:
#   Add this line to your .bashrc or .bash-profile:
#
#       source /path/to/.py_autovenv
#
#   Go to your project folder, run "virtualenv .venv", so your project folder
#   has a .venv folder at the top level, next to your version control directory.
#   For example:
#   .
#   ├── .git
#   │   ├── HEAD
#   │   ├── config
#   │   ├── description
#   │   ├── hooks
#   │   ├── info
#   │   ├── objects
#   │   └── refs
#   └── .venv
#       ├── bin
#       ├── include
#       └── lib
#
#   You may also 
#
# See:
#   https://nolar.info/automatically-activate-virtualenv-on-cd/
#   https://gist.github.com/brianpkennedy/8943902

# Print all possible candidates for venv relative to the directory $1. Used in
# venv_find() for every directory starting from the current and up to the root.
# Only .venv will be recognized, but additional names may be added.
function venv_candidates () {
    echo $1/.venv
}

# Finds the closest venv directory, starting from $1, and going up to the root.
# If the target directory is not specified as an argument, current directory is used.
# Prints the venv path found, or nothing otherwise.
function venv_find () {
    local venv_root=${1:-"."}
    local venv_found=""

    # The cycle is just for the case with broken root folder detection - never do more than N iterations.
    for (( i=10; i > 0; i-- )); do
        local venv_real=$(cd $venv_root && pwd -P)
        local venv_name=$(basename $venv_real)
        for candidate in $( venv_candidates $venv_real ) ; do
            # echo CANDIDATE=$candidate >&2
            if [ -f "$candidate/bin/activate" ]; then
                echo $(cd $candidate && pwd -P)
                return
            fi
        done

        if [ "$venv_real" = "/" ]; then
            break
        fi
        venv_root=$venv_root/".."
    done
}

# Find current venv path using $VIRTUAL_ENV. Active venv will have variable set,
# and deactivate function available.
function venv_curr () {
    if [ -n "$VIRTUAL_ENV" -a "$(type -t deactivate)" = 'function' ]; then
        echo $VIRTUAL_ENV
    fi
}

# Activates the closest venv relative to the working dir, if different from
# current active venv. Deactivates current venv when its directory tree is left.
function venv_auto () {
    venv_new="$(venv_find)"
    venv_old="$(venv_curr)"

    if [ -z "$venv_new" -a -n "$venv_old" ]; then
        echo "DEACTIVATE $venv_old"
        deactivate
    elif [ -n "$venv_new" -a "$venv_new" != "$venv_old" ]; then
        echo "ACTIVATE $venv_new"
        # Uncomment if using your own PS1
        VIRTUAL_ENV_DISABLE_PROMPT=1
        source "$venv_new"/bin/activate
    fi
}

# Prints out the venv name for use in bash PS1, for example:
#   PS1="$(_virtualenv_ps1) "$PS1
_venv_ps1 () {
    if [[ -z "$VIRTUAL_ENV" ]]; then
        printf ""
    else
        # venv folder name
        printf "$(basename $(venv_curr))"
        # Project dir's name
        # printf "$(basename $(dirname $(venv_curr)))"
    fi
}

export PROMPT_COMMAND="venv_auto; $PROMPT_COMMAND"
